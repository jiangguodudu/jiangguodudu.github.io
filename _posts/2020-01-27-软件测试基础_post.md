# 软件测试基础

## 目标

软件测试相关概念、软件生命周期及各阶段相关的工作、软件测试对象和原则、软件开发模型、软件测试模型及各模型的特点、软件测试的方法和类型、软件测试质量及测试与QA的关系和区别。

## 测试相关概念

* IT：信息科技和产业

* 软件：一系列按照特定顺序组织的计算机数据和指令的集合 （程序+数据+文件）

* 产品：能够提供给市场，被人们使用和消费，并能满足人们某种需求的任何东西，包括有形的物品、无形的服务、组织、观念或它们的组合。

* 项目：指一系列独特的、复杂的并相互关联的活动，这些活动有着一个明确的目标或目的，必须在特定的时间、预算、资源限定内，依据规范完成。

  [产品和项目的区别](https://blog.csdn.net/xiaxu713/article/details/62044848)
  
  > **产品：没有特定的客户，项目：有特定的客户。**

## 软件测试

* 功能测试
  * 接口测试
* 性能测试
* 自动化测试
* 安全测试

### 定义

​	1983，IEEE提出软件工程标准术语，定义如下：使用==人工或自动==的手段来运行或测试某个系统的过程，其目的在于**检验它是否满足规定的需求**或是弄清==预期结果与实际结果之间的差别==。

>   《软件测试艺术》：测试是为了发现错误而执行的一个程序或系统过程。
>
>   《软件测试完全指南》：测试是以评价一个程序或系统属性为目标的一种活动，是对软件质量的度量。

### **软件测试的目的**

​    1）软件测试是为了发现错误而执行程序的过程。

​    2）测试是为了证明程序有错，而不是证明程序无错。（发现错误不是唯一目的）

​    3）一个好的测试用例在于它发现至今未发现的错误。

​    4）一个成功的测试是发现了至今未发现的错误的测试。

注意：

1.  **测试并不仅仅是为了要找出错误。通过分析错误产生的原因和错误的分布特征。**可以帮助项目管理者发现当前所采用的软件过程的缺陷，以便改进。同时，通过分析也能帮助我们设计出有针对性的检测方法，改善测试的有效性。

2.  **没有发现错误的测试也是有价值的，完整的测试是评定测试质量的一种方法**。详细而严谨的可靠性增长模型可以证明这一点。例如Bev Littlewood发现一个经过测试而正常运行了n个小时的系统有继续正常运行n个小时的概率。

3.  **软件测试的目的是为了保证软件产品的最终质量，在软件开发的过程中，对软件产品进行质量控制。**一般来说软件测试应由独立的产品评测中心负责，严格按照软件测试流程，制定测试计划、测试方案、测试规范，实施测试，对测试记录进行分析，并根据回归测试情况撰写测试报告。测试是为了证明程序有错，而不能保证程序没有错误。

[软件测试](https://www.baidu.com/s?wd=软件测试&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)指的是在规定的条件下对程序进行操作，以发现程序错误，衡量软件质量，并对其是否能满足设计要求进行评估的过程。其目的主要有以下几点：

1、发现被测对象与用户需求之间的差异，即缺陷。

2、**通过测试活动发现并解决缺陷，增加人们对软件质量的信心。**

3、通过测试活动了解被测对象的质量状况，为决策提供数据依据。

4、通过测试活动积累经验，预防缺陷出现，降低产品失败风险。

[软件测试](https://www.baidu.com/s?wd=软件测试&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)的原则：

1、测试应该尽早进行，最好在需求阶段就开始介入，因为最严重的错误不外乎是系统不能满足用户的需求。

2、程序员应该避免检查自己的程序，[软件测试](https://www.baidu.com/s?wd=软件测试&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)应该由第三方来负责。

3、设计测试用例时应考虑到合法的输入和不合法的输入以及各种边界条件，特殊情况下还要制造极端状态和意外状态，如网络异常中断、电源断电等。

4、应该充分注意测试中的群集现象。

5、对错误结果要进行一个确认过程。一般由A测试出来的错误，一定要由B来确认。严重的错误可以召开评审会议进行讨论和分析，对测试结果要进行严格地确认，是否真的存在这个问题以及严重程度等。

6、制定严格的测试计划。一定要制定测试计划，并且要有指导性。测试时间安排尽量宽松，不要希望在极短的时间内完成一个高水平的测试。

7、妥善保存测试计划、测试用例、出错统计和最终分析报告，为维护提供方便。

### 发展史

![image-20191024100638244](/images/image-20191024100638244.png)



> 调试:就是在已知错误的情况下，对软件程序代码做出的一系列检查，校正的过程。
>
> 软件测试则是在未知错误的情况下，检查程序代码是否有问题的过程。
>
> 真正区分测试与调试的意义在于，软件测试从软件质量保证的角度来检查程序代码是否有错误，而调试则是为了解决当前已知的错误，调试活动根本无法替代软件测试活动。  
>
> 
>
> ​		软件测试就是为了发现错误而审查软件文档、检查软件数据和执行程序代码的过程， 其目的在于在软件交付使用前充分发现缺陷并协助相关部门定位、解决缺陷，最后交付一个高质量的软件给用户。软件测试是软件生存周期的一个重要阶段，其主要任务是对被测对象，从初期的需求规格说明书，到最后的系统交付使用，整个过程进行检查、验证，以确保软件质量。
>​		基于不同的立场，存在着两种完全不同的测试目的。**从用户的角度出发，普遍希望通过软件测试暴露软件中隐藏的错误和缺陷，以考虑是否可接受该产品。而从软件开发者的角度出发，则希望测试成为表明软件产品中不存在错误的过程，验证被测软件已正确地实现了用户的需求，确立人们对软件质量的信心**。
> 
>
> 
> 软件测试人员在实际的工作过程中应该如何处理呢？
>根据软件测试的定义， 我们不难得知， 软件测试的目的是通过科学的测试方法，找出软件中存在的缺陷，最终得到一个高质量的软件产品，那么确保用户满意将是我们的服务宗旨，如何找到更多的软件缺陷，是我们工作的重点。所以，我们需要从客户的角度出发，按照正确的业务流程尽最大可能去模拟用户的行为习惯，从客户角度出发，找出产品中的缺陷。在此过程中，应以《需求规格说明书》为基本依据，结合软件产品的设计文档，以及项目经验设计高效的测试用例，只有这样，才能达到我们测试的目的。
> 从广义上讲， 软件测试是指软件产品生存周期内所有的检查、评审和确认活动。如：设计评审、文档审查、单元测试、集成测试、系统测试、验收测试等。从狭义上讲，软件测试是对软件产品质量的检验和评价。它一方面检查、揭露软件产品质量中存在的质量问题，同时又需对产品质量进行客观的评价并能提出改进意见。  



### 为什么做软件测试

软件bug实例（导弹、千年虫bug）

* 糟糕的测试程序可能导致任务的失败，影响操作的性能和可靠性，导致维护阶段的成本提高
* 好的测试程序可以降低项目的主要成本，极大地帮助你定义需求和设计
* 好的测试程序可以迫使你在工作中必须正式和处理问题，使得修改缺陷成本降低
* 好的测试程序有助于发现许多问题，并是你尽早知道你处理问题

### 软件测试需要的技能

Linux、数据库（oracle、mysql、SQLServer、DB2）、接口、自动化、性能

* 硬实力：学历、专业、经验、测试技术、开发技能、业务知识
* 软实力：责任心、沟通能力、团队合作精神(测试是连接开发和客户的接口，与开发人员沟通，我
    们需要从专业知识角度考虑  )、耐心、细心、信心、风险防范意识、时时保持怀疑态度，并且有缺陷预防的意识  、持续学习能力

## 软件生命周期-----important

* SDLC（System Development Life Cycle）：软件产生直到报废或停止使用的生命周期

  ​			可行性研究-----需求---设计----开发、coding---测试和维护-------下线，交付

  * 需求规格说明（SRS）、概要设计（HLD  High LEvel Design）、详细设计（LLD   Low Level Design）

  

  >   **市场调研**
  >
  >   市场调研主要有两种形式：一种是主动模式，另外一种是被动模式。首先我们来看看主动模式。  
  >
>   主动模式
>   所谓主动模式，是将公司或者企业作为需求接收的被动方，而需求的提出者作为主动方。这种模式中，需求提出者有明确的主体，如果 A 公司需要 B 公司为其开发一套企业信息管理系统，那么 A 公司为需求提出者，主动方， B 公司为需求接收者，被动方。
>   这种模式下进行需求调研，一般来说比较容易处理，同时因为有明确的对象，总体项目收益较被动模式明显。比如，华为公司为中国移动广东公司所做业务运营系统，中国移动广东公司是需求的提出者，主动方，而华为公司则是需求接收者，被动方。当项目开发过程中，有不明确、疑问的地方，华为公司可直接咨询移动公司，以便得到更详细，更准确的需求。这种模式属于一对一的模式。
>   被动模式
>   所谓被动模式就是在没有明确的需求提出者时，由公司或企业主动提出给特定使用用户群提供某种产品的模式。如某公司发现在邮箱业务上存在大量的潜在客户，那么可由公司的市场人员，主动提出此类需求。
>   这种模式较主动模式有明显的差异，在用户群不确定的情况，需求将是不明确的，给公司或企业的带来一定风险，后期的项目运作过程可能面临着多次变更的风险。比如，今年的奥运会，有些门户网站发现如果在奥运会期间，提供网络直播，网友互动的平台，可能为公司带来名誉或者经济上的利益，那么则会开发相应的平台。这时，所面向的用户群体就是广大的网络用户，而无特定明确的主体，这种项目风险较大，甚至于失败。 2004 年的世界杯，搜狐就在视频播放这一领域大赚一笔，打败了新浪。这是成功的例子，也有失败的，前些年比较流行的网络交友，如世纪佳缘，做的非常成功，于是也有很多公司、网站开展这样的业务，但最后因市场的饱和及管理问题，绝大多数都失败了。所以这种模式下，风险非常大。被动模式属于一对多的模式，这种模式需要市场人员，管理人员有很好的市场洞察力及发展眼光，才能在一定程度上保证项目成功。
>
>   *    市场调研主体：市场人员、销售人员等
>   *   调研方式：客户走访，市场观察，报刊媒体等
>   *   输出文件： 《 XXX 项目市场调研分析报告》  
>
>   **可行性研究**
>
>   可行性研究方法是以预测为前提，以投资效果为目的，从技术上、经济上、管理上进行全面综合分析研究的方法。可行性研究的基本任务，是对新开发产品或升级产品的主要问题，从技术经济角度进行全面的分析研究，并对其投产后的经济效果进行预测，在既定的范围内进行方案论证的选择，以便最合理地利用资源，达到预定的社会效益和经济效益。
>   从软件角度看，可行性研究重点解决的是前期的市场调研是否可行，能否在一定的成本压力下，持续的为公司、企业带来适当的利益，无论从社会效益还是经济效益。
>
>   *   可行性研究主体：市场人员、销售人员等
>   *   可行性研究对象：在市场调研阶段产生的《 XXX 项目市场调研分析报告》
>   *   输出文件： 《 XXX 项目可行性分析报告》
>
>   **产品立项**
>
>   在前期的市场调研、可行性研究经过评审确认可行后，则由需求调研人员牵头，进行产品立项，并进行产品小组的建立，同时制定产品的运作计划，如需求调研，
>   产品设计，产品测试，产品发布等等一系列的工作步骤及时间点。
>    		立项负责人：市场调研人员
>   		工作内容：提交产品立项申请，审批通过后，制定产品计划书，确定产品各个阶段的工作流程及时间进度表。  
>
>   
>
>   **需求调研**
>   产品立项后，则需要进行详细的需求调研。需求调研同样有两种模式：主动模式和被动模式。
>   在主动模式下，公司需要派出需求调研小组与客户直接沟通，以获得正确可靠的需求。被动模式是市场调研人员根据自己的经验判断，无明确的需求提出者，这样的项目有一定的风险。
>   需求调研是整个项目最为重要的环节，此环节输出的一切资料都是后期工作的依据。所以，很多公司在这个阶段会投入较长的时间，花费大量的人力、物力，以保证需求调研的充分及正确。从测试角度来说，测试人员需在这个阶段就参与进来，从初期的需求调研到后期的系统测试，测试人员能够在第一时间接触处初始需求，对整个项目质量是有积极意义的。
>   需求调研期间一般要做以下几件事：
>   1、与客户座谈，输出需求记录表；
>   2、走访实际业务流水线，掌握客户实际业务流程；
>   3、输出需求整理文档，最好做出 demo 让用户确认；
>   4、最终输出用户需求规格说明书；
>   需求调研中可能存在的问题
>   1、用户无法确切描述其所期望的系统功能；
>   2、无法获取实际的业务流程；
>   3、无法获得客户的支持，使得需求调研流于表面
>   在上述几个问题中，我们需要特别注意的是第一点，因为没有准确正确的需求，将会给我们的项目开发测试埋下炸弹，带来无尽的变更与返工。
>
>   >   需求调研参与人员：市场人员，开发人员，测试人员等  
>
>   >   调研对象：客户或假想客户（广泛的用户群）
>   >   输出：需求规格说明书
>
>   
>
>   **设计开发**
>   在输出需求规格说明书，经过评审确定后，则由项目组内的开发人员进行系统设计。一般的，如果公司有专门的系统架构师，则会由系统架构师进行系统的概要设计，在需求阶段已经提出系统的开发模式，在概要设计阶段，主要解决的是系统的整体架构，从稳定性，安全性，扩展性，可维护性等方面进行设计，然后再进行系统的详细设计，数据库设计等相关事宜。
>
>   *    设计人员：系统架构师、项目开发小组
>   *   输出：项目开发计划、概要设计文档、详细设计文档、数据库设计文档等
>
>   **系统测试**
>   在开发部门完成代码编写、模块集成后，由测试部门进行该项目的测试，按照前期的测试计划，利用测试用例进行系统的功能、性能测试。在经过多次版本的迭代后，完成系统测试，输出测试报告。
>
>   *   测试人员：项目测试小组
>   *   输出：测试计划、测试方案、测试用例、功能测试报告、性能测试报告等。
>
>   **产品发布**
>   经过开发部门、测试部门和其他部门的努力，产品在预定的日期完成，由项目组择日发布。
>
>   *   发布人员：项目实施人员、市场部等
>   *    输出：客户现场项目实施报告等
>
>   **产品维护**
>   交付使用后，需根据需求调研阶段的协议，制定产品维护流程，在出现问题需及时解决，直到产品使用废弃或升级，进行新的生命周期。
>    产品升级
>   在软件产品使用到一定期限后，可以根据先前的约定进行升级，或者根据客户新的需求，再次进行新需求的调研开发等。比如现在很多公司给一些企业做信息管理系统，类似于 ERP，往往会分成几期来做，这里面就有一个升级换代的问题。其实，在这个过程中，也有产品是消亡的，比如奥运会的门票销售系统，在奥运会结束后， 该系统的使用寿命也就结束了，主办方可能根据其他的需要进行定制，改版，应用到其他项目中去。  

  * ~~测试~~
  
    * ~~-------单元测试/单体测试~~
    * ~~-------集成测试/接口测试（页面和页面之间的参数传递有没有问题）~~
    * ~~--------系统测试：从整个项目的宏观角度进行测试~~
    * ~~--------交付测试： 用户测或指导用户测试~~
    
    > * ~~α测试：邀请一些用户代表来到开发现场对软件进行使用，如果有疑问或bug，开发人员现场解答或修复~~
    > * ~~β测试：用户在自己家里或办公地点使用软件，如果有问题，可以通过邮件或电话等形式反馈给开发人员，这种情况下开发人员是不在现场的~~

## 项目组成员

* 项目经理（PM programmer Manager）：立项（可行性报告等）、计划、关联产品、关联需求等。
* 产品经理：收集需求反馈、建立产品、整理需求
* 设计人员：设计系统架构、概设、详设（业务设计师BSE）
* 开发：编码（软件开发工程师SE  software engineer）
* 测试人员：设计用例、执行测试、提交bug（TT ----tester、TSE）
* 配置管理员：部署系统（CM），负责制定配置管理计划，针对项目进行配置库的规划；搭建配置管理环境，建立和维护配置库，保证配置库稳定运行等
* QA：贯穿全过程、指定规范、辅助、审计。

## 测试基本原则

* 测试是上下文相关的

* 穷尽测试是不可能的
* 测试尽早介入
* 杀虫剂悖论
* 缺陷群集性
* ==测试证明存在缺陷==
* 无错谬误

## 软件测试的对象

==程序 + 数据 + 文档==

## 软件开发的模型

* 瀑布型

  ![image-20191024172812738](/images/image-20191024172812738.png)

  瀑布模型（Waterfall Model）是一个项目开发架构，开发过程是通过设计一系列阶段顺序展开的，从系统需求分析开始知道产品发布和维护，每个阶段都会产生循环反馈。 项目开发进程从一个阶段“流动”到下一个阶段 

  * 优点：
    * 为项目提供了按阶段划分的检查点
    * 当前一阶段完成后，只需去关注后续阶段
    * 可在迭代模型中应用瀑布模型
    * 提供了一个模板，这个模板使得分析、设计、编码、测试和支持的方法可以在该模板下有一个共同的指导
  * 缺点：
    * 各个阶段的划分完全固定，阶段之间产生大量的文档，极大的增加了工作量
    * 由于开发模型是线性的，用户只有等到整个过程的默契才能见到开发成果，从而增加了开发风险
    * 通过过多的强制完成日期和里程碑来跟踪各个项目阶段
    * 瀑布模型的突出缺点是不适应用户需求的变化

* 原型

  ![image-20191024175218461](/images/image-20191024175218461.png)

  快速原型模型需要迅速建造一个可以运行的软件模型，以便理解和澄清问题，使开发人员和用户达成共识，最终在确定的客户需求基础上开发客户满意的软件产品。 ==快速原型模型允许在[需求分析](https://baike.baidu.com/item/需求分析/2012709)阶段对软件的需求进行初步而非完全的分析和定义，快速设计开发出软件系统的原型==，该原型向用户展示待开发软件的全部或部分功能和性能；用户对该原型进行测试评定，给出具体改进意见以丰富细化[软件需求](https://baike.baidu.com/item/软件需求/256136)；开发人员据此对软件进行修改完善，直至用户满意认可之后，进行软件的完整实现及测试、维护。 

  * 优点：克服瀑布模型的确定，减少由于软件需求不明确带来的开发风险
  * 缺点所选用的开发技术和工具不一定符合主流的发展；快速建立起来的系统结构加上连续的 修改可能会导致产品质量低下 

* 敏捷模型：以人为核心、迭代、循序渐进的开发方法

  [敏捷开发模式]( [https://baike.baidu.com/item/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/8395733?fr=aladdin](https://baike.baidu.com/item/敏捷开发模式/8395733?fr=aladdin) )

* 其他研发模型：

  * 螺旋模型：人月（200个人月----200个人1个月或100个人2个月或10个人20个月）
  * RUP模型（Rational Unified Process）

## [软件测试的模型](https://blog.csdn.net/baidu_37964071/article/details/82290067)

[软件测试模型对比]( http://www.51testing.com/html/70/n-4461370.html )

* ==V模型==

  需求分析-->概要设计--详细设计--软件编码--单元测试--集成测试--系统测试--验收测试

  * 优点

    既包括低层测试又包括了高层测试，低层测试是为了源代码的正确性，高层测试是为了使整个系统满足用户的需求

  * 缺点

    把测试过程作为在需求分析、概要设计、详细设计及编码之后的一个阶段，不能体现“尽早地和不断地进行软件测试”的原则

![image-20191024140153461](/images/image-20191024140153461.png)

* ==W模型==

  * 优点

    开发与测试并行，有利于尽早发现问题，有利于及时的了解项目的测试风险，来及早的执行相应的应对方案，加快项目的进度

  * 局限性

     无法支持迭代、自发性以及变更调整

  ![image-20191024140329486](/images/image-20191024140329486.png)

* H模型

  把软件测试看成一个完全独立的流程，与其他流程并发进行，比如设计流程，编码流程，甚至是测试流程

  * 优点：
    * 软件测试是一个独立的过程，贯穿产品的整个生命周期，与其他流程并发的进行
    * 软件测试要尽早准备，尽早执行
    * 软件测试是根据被测物的不同而分层次进行的
    * 如同层次的测试活动可以使按照某个次序先后进行的，但也可能是反复的
    * 软件测试不仅仅指测试的执行，还包括很多其他的活动

  ![image-20191024140632951](/images/image-20191024140632951.png)

* X模型

  解决交接和频繁集成周期的问题

   ![img](/images/15243603_2019070910252545OLK.png) 

* 前置模型

  •概述
         –是由Robin FGoldsmith等人提出的
         –是一个将测试和开发紧密结合的模型
         –提供了轻松的方式，可以使你的项目加快速度
  
  •优点
        –质量保证和质量控制严格，增强测试质量
        –测试贯穿于开发的时时刻刻，有效地提高了测试
        –对验收测试非常强调，并用双重方式测试，保证系统能成功验收
  •缺点
        –流程管理复杂
        –需求变化时很难应付
        –对文档、质量管理、配置管理、项目管理要求较高
  
  •适用范围
  
     –长期项目
  
     –需求基本不变更
  
  ![img](/images/20151230152351352.png)

通常可以在W模型的框架下，运用H模型的思想进行独立的测试。当有变更发生时，按X模型和前置模型的思想进行处理（https://blog.csdn.net/python_jeff/article/details/98720659）

## 软件测试阶段

![image-20191024142513550](/images/image-20191024142513550.png)

### 需求测试

*   需求测试不等同于后面的阶段集成测试或者系统测试，后面的测试都是软件已经编写完成的条件下，判断软件是否会出错。而需求测试，知识验证需求是否真正是用户所期望的。
*   [质量的真正缔造者-需求](https://blog.csdn.net/ljah/article/details/2541947)

* 返工： 70%~85%由于需求

* 重点：检查需求规格说明书（SRS）
  * 完整性
  
  每一项需求都必须将所要实现的功能描述清楚，从而为开发人员设计和实现这些功能提供所有必要的需求依据。  
  
  * 正确性
  
  每一项需求都必须准确地陈述其要开发的功能。  
  
  * 一致性
  
  一致性是指与其它软件需求或高层（系统，业务）需求不相矛盾， 或者与我们的项目宣传资料要一致。  
  
  * 可行性
  
  每一项需求都必须是在已知系统和环境的权能和限制范围内可以实施的。  
  
  * 无二义性
  
  对所有需求说明的读者都只能有一个明确统一的解释，由于自然语言极易导致二义性，所以尽量把每项需求用简洁明了的用户性的语言表达出来。  
  
  * 健壮性
  
  需求的说明中是否对可能出现的异常进行了分析，并且对这些异常进行了容错处理 。
  
  * 必要性
  
  “必要性”可以理解为每项需求都是用来授权你编写文档的“根源”。要使每项需求都能回溯至某项客户的输入，如需求用例或别的来源。  
  
  * 可测试性
  
  每项需求都能通过设计测试用例或其它的验证方法来进行测试。  
  
  * 可修改性
  
  每项需求只应在 SRS（软件需求规格说明书） 中出现一次。这样更改时易于保持一致性。另外，使用目录表、索引和相互参照列表方法将使软件需求规格说明书更容易修改。  

### 单元测试------详细设计说明书

* 定义：针对软件基本组成单元（软件设计的最小单位）来进行正确性检验的测试工作
* 目的：检测软件模块对《==详细设计说明书==》的符合程度

>   **单元测试又称为模块测试，顾名思义，就是对程序代码中最小的设计模块单元进行测试。单元测试是在软件开发过程中要进行的最低级别的测试活动。在单元测试活动中，我们主要采用静态测试与动态测试相结合的办法。**首先采用静态的代码走查，检查程序代码中不符合编程规范，存在错误或者遗漏的地方，同时使用代码审查的方法，小组检查项目代码，以期发现更多的问题， 然后再使用单元测试工具，比如 JUnit 等工具进行程序代码内逻辑结构、函数调用等方面进行测试。据业界统计，单元测试一般可以发现大约 80%的软件缺陷。
>   单元测试对测试人员的要求相对较高，一般需要有几年的代码编写经验，并且要十分熟悉当前的被测系统，以及该系统是否与其他系统的接口关联情况。在大多数公司中，单元测试一般情况下有对应的开发工程师负责。
>   在实际的工作过程中，很多人认为单元测试没有必要，认为这个过程耽误了工作进度，没什么实际的效果， 其实不然， 软件测试活动贯穿于软件生产的整个过程，每个环节的检查测试都是不可缺少的，我们知道缺陷发现的越早，其修复的代价也就越小。单元测试在编码阶段占据着非常重要的地位。编码只是一方面，还需检查编码，保证代码的质量，所以说，在软件生产过程中及时的开展单元测试是非常有必要的，可以降低编码的错误率，提高编码质量  

单元测试：

https://www.cnblogs.com/SETtest/p/10821033.html

### 集成测试------概要设计说明书

* 定义：对单元之间及单元与第三方接口之间的测试，目的是验证接口是否与设计相符，是否与需求相符
* 目的：
* 策略：自底向上或自顶向下  渐增式



>   我们知道，个体不代表全部，在单元测试阶段，发现并解决了部分的问题，但不能解决所有的问题。在当前环境下，我们可能觉得代码质量已经非常好了，至少我们的能力范围内不能再发现缺陷了。此时，仅仅是一个代码模块，功能模块，一旦组合起来，可能相互之前的问题暴露了。
>   **集成测试，又称为组装测试，就是将软件产品中各个模块组装起来，检查其接口是否存在问题，以及组装后的整体功能、性能表现。**在开展集成测试之前，我们进行了深入的单元测试（当然，实际工作中大多公司不会做单元测试，仅有程序员各自检查自己的代码），从个体来讲，可能解决了很多的缺陷，但所有的个体组合起来，就可能出现各种各样的问题。 1+1<2 的问题，此刻尤为突出。
>   在单元测试阶段，我们无法发现资源争用、接口调用、时钟延迟等等问题。假如有两个模块 A、 B，一个数据在 A 处处理时因代码问题，延迟了 0.01 秒，然后流转到 B 模块处理，又延迟了 0.01 秒，那么对于个体来讲，可能 0.01 秒算不了什么，但当数据流转的环节增加时，相应的延迟时间也在不断的增加，最终的累加数
>   据可能带来非常严重的后果，二战期间的爱国者导弹时间，就给了我们深刻的教训。每个环节的缺陷在最终被放大后，可能会引起软件的失效。所以，单元测试阶段的成果并不能保证集成测试没有问题。采用科学有效的集成测试方法，在软件生产活动中是非常有必要的。  
>
>   **集成测试一般可采用非增式集成方法、增式集成方法（自底向上集成；自顶向下集成；组合方式集成）等策略进行测试**，利用以黑盒测试为主，白盒测试为辅的测试方法进行测试。集成测试人员一般有测试工程师担当，开发人员将经过单元测试的代码集成后合成一个新的软件版本，交由配置管理员，然后测试组长会从配置管理员处提取集成好的版本进行测试。就像一个自行车生产线一样，工人将自行车的各个部件先检查，没有问题后再组装成一辆完整的自行车交由质检人员进行检查。 软件测试工程师就像这里的质检人员，负责对集成组装后的软件版本进行检测。**集成测试阶段主要解决的是各个软件组成单元代码是否符合开发规范、接口是否存在问题、整体功能有无错误、界面是否符合设计规范、性能是否满足用户需求等等。**  

### 系统测试

* 定义：将已经集成好的系统进行彻底的测试，以验证软件系统的正确性和性能是否满足要求
* 目的：通过与SRS相比，发现软件与系统需求定义不符合或与之矛盾的地方



>   **系统测试，是将通过集成测试的软件，部署到某种较为复杂的计算机用户环境进行测试，**这里所说的复杂的计算机用户环境，其实就是我们一般用户的计算机环境。比如，我们开发了一套财务软件，软件中采用了 EXCEL 2000 版中的某些绘图控件，在集成测试阶段，我们大多数是在一种比较干净的系统进行测试。所谓的干净，就是在测试机上没有多余的软件，仅有所需的操作系统和被测软件。当我们集成测试完成后，就将被测软件置入比较复杂的运行环境下，进行集成和确认测试。在这个过程中，我们往往有很大的收获，比如进行安装测试的时候，会发现在集成阶段安装没有问题，而在复杂的用户环境下，却不能安装。举个例子，前面所说的财务软件，当我们的计算机中装有新版本的 EXCEL 时，如 EXCEL 2003，就可能出现无法正常使用该软件的问题，因为该财务软件所需的控件在 EXCEL 2003 可能不存在，或者不适用。类似于这样的问题，就需要我们将被测软件置入一个较为普遍的用户计算机环境中。
>
>   **系统测试的目的在于通过与系统的需求定义作比较，发现软件与系统的定义不符合或与之矛盾的地方。**这个阶段主要进行的是安装卸载测试、兼容性测试、功能确认测试、安全性测试等等。系统测试阶段采用黑盒测试方法，主要考查被测软件的功能与性能表现。如果软件可以按照用户合理地期望的方式来工作的时候，即可认为通过系统测试。系统测试过程其实也是一种配置检查过程，检查在软件生产过程中是否有遗漏的地方，在此时做到查漏补缺，以确保交付的产品符合用户质量要求。  

### 确认测试

又称有效性测试，它的任务是验证软件的有效性，及验证软件的功能和性能及其他特定是否与用户的要求一致

### 验收测试

交付用户部署之前，进行验收测试， 验收测测试的目的是确保软件的准备就绪，向软件购买展示软件系统满足其用户的需求。 

### α测试和β测试

α测试：Alpha测试（α测试）是由一个用户在开关环境下进行的测试，也可以是公司内部的用户在模拟实际操作环境下进行的受控测试，Alpha测试不能由测试员完成。Alpha测试发现的错误，可以在测试现场立即发聩给开发人员，由开发人员及时分析和处理。目的是评价软件产品的功能，可使用性、可靠性、性能和支持。尤其注重产品的界面和特色。Aplha测试可以从软件产品编码结束之后开始，或在模块（子系统）测试完成后开始。有关的手册（草稿）等应该在Alpha测试前准备好。



β测试：Beta测试（β测试）是软件的多个用户的实际使用环境下进行的测试。开发者通常不在测试现场，Beta测试不能由程序员或测试员完成。因而，Beta测试是在开发者无法控制的环境下进行的软件现场应用。在Beta测试中，由用户记下遇到的所有问题，包括真实的以及主管认定的，定期向开发者报告，开发者在综合用户的报告后，做出修改，最后将软件产品交付给全体用户使用。Beta测试着重于产品的支持性，包括文档、客户培训和支持产品的生产能力。只有当Alpha测试达到一定可靠程度后，才开始Beta测试。由于Beta测试的主要目标是测试可支持性，所以Beta测试应该尽可能由主持产品发行的人员来管理。


### UAT测试

user Acceptance Test用户接受度测试，验证系统的可用性

###回归测试

* 定义：软件在测试或其他活动中发现的缺陷经过修改后进行的测试
* 目的：验证缺陷得到修复
* 回归测试可以发生在任何一个阶段，包括单元测试、集成测试和系统测试
* 验证已经被修改好的错误是不是被修复
* 策略：
  * 完全重复测试：
  * 选择性重复测试：
    * 覆盖修改法
    * 周边影响法
    * 指标达成方法
* 流程（适合单元测试、集成测试和系统测试）：
  * 在测试策略制定阶段，制定回归测试策略
  * 确定需要回归测试的版本
  * 回归测试版本发布,按照回归测试策略执行回归测试
  * 回归测试通过，关闭缺陷跟踪单（问题单）
  * 回归测试不通过，缺陷跟踪单返回开发人员，开发人员重新修改问题，
    再次提交测试人员回归测试  

### 冒烟测试

冒烟测试的对象是每一个新编译的需要正式测试的软件版本，==目的是确认软件的基本功能正常==，可以进行后续的正式测试工作。



## 软件测试的类型

### 功能测试

* 定义：根据产品的需求规格说明书和测试需求列表，验证产品的功能实现是否符合产品的需求规格
* 目标：主要是为了发现以下几类错误：
  * 是否有不正确或遗漏的功能
  * 功能实现是否满足用户需求和系统设计的隐藏需求
  * 输入能否正确接收？能否正确输出结果

### 性能测试

* 性能测试（performance testing）是用来测试软件在集成系统中的运行性能的
* 目标是度量系统相对于预定义目标的差距
* 性能测试必须要有工具支持，失眠上有一些专门用于GUI后Web的性能测试工具，如Loadrunnner、Jemeter、SilkPerformer、WebLoad
* 指标：CPU、内存、吞吐量（IO）、信道、每个模块执行时间百分比、一个模块等待IO完工的百分比、指令随时间的跟踪路径、每一组指令页换入和换出的次数、系统反应时间

### 负载测试

负载测试是超过被测对象标准性能负荷指标下，验证系统的负载承受能力，并要求在超负荷情况下，依然正常实现业务功能

### 压力测试

目的是调查系统在其资源超负荷的情况下的表现。尤其感兴趣的是这些对系统的处理时间有什么影响。这类测试在一种需要反常数量、频率或资源的方式下执行系统

### 容量测试

* 是系统承受超额的数据容量来发现它是否能够正确处理
* 容量测试是面向数据的，并且它的目的是显示系统可以处理目标内确定的数据容量

### 安全性测试

* 用来验证集成在系统内额保护机制是否能够在实际中保护系统不受到非法的侵入。用来保证系统本身数据的完整性和保密性。
* 安全性问题：
  * 没有口令是否可以登录到系统中
  * 各级用户权限划分是否合理
  * 错误和文件访问是否适当地被记录
  * 系统配置数据是否能正确保存，系统故障时是否能恢复
* 内容：
  * 系统登录
  * 用户管理
  * 防火墙
  * 系统数据
  * web安全
  * 数据库安全
  * 内部通信协议
  * 系统防病毒测试

### GUI测试

针对软件系统GUI界面进行的测试

* 内容：

  * 界面实现与界面设计的吻合情况
  * 确认界面处理的正确性

* 工具

  QTP（QuickTestProfessional、selenium等）

### 可用性测试

考虑产品是否符合实际应用情况，是否符合用户习惯和特殊要求，操作方式是否方便合理，设备和用户间的交互信息是否准确易于理解、是否遵从行业习惯、外观/界面是否美观等。

### 安装和卸载测试

  不仅是找安装软件本身的错误，而且还要找安装文档的错误  

### 异常测试

通过人工干预手段是系统产生异常，通过验证异常前后的功能和运行状态，达到检验系统的容错、排错和恢复功能。是系统可靠性评价的重要手段

### 文档测试

验证用户文档是正确的并且保证操作手册的过程能够正确工作。

### 网络测试（接口测试）

* 网络环境下和其他设备对接，进行系统功能、性能和指标方面的测试，保证设备对接正常
* 内容：
  *   网络测试考察系统的处理能力、系统兼容性、系统稳定可靠性及用户使用等方面。
    如通信产品，主要进行协议测试：
    • 一致性测试：检测所实现的系统与协议规范符合程度
    • 性能测试：检测协议实体或系统的性能指标（数据传输率、联接时间，执行速度、
    吞吐量、并发数等）
    • 互操作性测试：检测同一协议不同实现厂商之间，同一协议不同实现版本之间、或同一类协议不同实现版本之间互通能力和互连操作能力
    • 坚固性测试：检测协议实体或系统在各种恶劣环境下运行的能力（信道被切断、通
    信设备掉电、注入干扰报文等）  

### 稳定性测试

* 在一定负荷情况下、长时间的运行情况
* 增加业务，原有业务是否受到影响，长时间运行，系统状况如何

### 兼容性测试

  兼容性测试验证被测对象与硬件、其他软件之间的兼容情况  

## 软件测试方法

- [x] 黑盒测试和白盒测试、灰盒测试

- [x] 静态测试和动态测试

- [x] 人工测试和自动化测试

### 黑盒测试

把被测对象看成一个黑盒，只考虑其整体的特性，不考虑其内部具体的实现

* 黑盒测试针对的被测对象可以是一个系统、一个子系统、一个模块、一个子模块、一个函数等
* 黑盒测试又可以被称为基于规格的测试
* 常见黑盒测试
  * 功能性测试：一种是顺序测试每个程序特性或功能，另一种途径是一个模块一个模块的测试，即每个功能在其最先调用的地方被测试
  * 容量测试：检测软件在处理海量数据时的局限性，能发现系统效率方面的问题
  * 负载测试：检测系统在一个很短时间内处理一个巨大的数据量或执行许多功能调用上的能力
  * 恢复性测试：主要保证系统在崩溃后能够恢复外部数据的能力
* 特点
  * 对于更大的代码单元来说（子系统甚至系统级）比白盒测试效率要高
  * 测试人员不需要了解实现的细节，包括特定的编程语言
  * 从用户的视角进行测试，很容易被大家理解和接受
  * 有助于暴露任何规格不一致或有歧义的问题

例：自动售卖机，投入5块钱，弹出饮料并找零



>**黑盒测试又叫功能测试、数据驱动测试或基于需求规格说明书的功能测试。该测试类别注重于测试软件的功能性需求。采用这种测试方法，测试工程师把测试对象看作一个黑盒子，完全不考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。**  

### 白盒测试

依据被测软件分析程序内部构造，并根据内部构造设计用例，来对内部控制流程进行测试，可完全不顾程序的整体功能实现情况

* 白盒测试是基于程序结构的逻辑驱动测试

* 白盒测试又可以被称为玻璃盒测试、透明盒测试、开放盒测试、结构化测试、逻辑驱动测试

* 为什么进行白盒测试

  * 白盒测试一般在测试前期进行，通过达到一定的逻辑覆盖率指标，使得软件内部逻辑控制结构上的问题能基本得到消除
  * 白盒测试能保证内部逻辑结构达到一定的覆盖程度，能够给予软件代码质量更大的保证
  * 白盒测试发现问题后解决问题的成本较低

* 常用技术分为静态分析和动态分析

  * 静态分析：控制流分析、数据流分析、信息流分析
  * 动态分析：逻辑覆盖测试（分支测试、路径测试等）、程序插装

    逻辑覆盖方法：语句覆盖、 判定覆盖、条件覆盖、判定条件覆盖、条件组合覆盖、路径覆盖  

例：白盒测试需要了解自动售卖机里面的每一步是怎么具体实现的



>   白盒测试又称结构测试、逻辑驱动测试或基于程序代码内部构成的测试。此时，测试工程师将深入考查程序代码的内部结构，逻辑设计等等。  



黑盒和白盒测试的优缺点

```
黑盒测试的优点有：
1. 比较简单，不需要了解程序内部的代码及实现；
2. 与软件的内部实现无关；
3. 从用户角度出发，能很容易的知道用户会用到哪些功能，会遇到哪些问题；
4. 基于软件开发文档，所以也能知道软件实现了文档中的哪些功能；
5. 在做软件自动化测试时较为方便。
※ 黑盒测试的缺点有：
1. 不可能覆盖所有的代码，覆盖率较低，大概只能达到总代码量的30%；
2. 自动化测试的复用性较低。
※ 白盒测试的优点有：
1. 帮助软件测试人员增大代码的覆盖率，提高代码的质量，发现代码中隐藏的问题。
※ 白盒测试的缺点有：
1. 程序运行会有很多不同的路径，不可能测试所有的运行路径；
2. 测试基于代码，只能测试开发人员做的对不对，而不能知道设计的正确与否，可能会漏掉一些功能需求；
3. 系统庞大时，测试开销会非常大。
```



### 灰盒测试

既利用被测对象的整体特性信息，又利用被测对象的内部具体实现信息，采用的就是灰盒测试的方法。两种信息占的比例不同，相应的灰度就不同。完全是整体特性信息，就是黑盒测试，完全是内部具体实现信息，就是白盒测试

* 典型的灰盒测试比如集成测试和系统测试时借助log信息

### 静态测试

不运行被测试的软件系统，而死采用其他手段和技术对被测试软件进行检测的一种测试技术。例如：代码走读、文档评审、程序分析等都是静态测试的范畴。常用技术有静态分析技术。

* 静态分析技术
  * 静态分析是一种不通过执行程序而分析程序执行的技术
  * 功能：检查软件的表示和藐视是否一致，没有冲突或者没有歧义，它瞄准的是纠正软件系统在描述、表示和规格上的错误，因此是任何进一步测试执行的前提
  * 三种不同的程序测试可能性：
    * 考虑程序是否满足编码规则，语法上是否具有一致性和完整性
    * 考虑文档描述是否规范、准确、便于查阅
    * 考虑程序和文档之间的一致性

### 动态测试

按照预先设计的数据和步骤去运行被测软件系统，从而对被测软件系统进行检测的技术。常用技术有动态分析技术

### 人工测试

测试活动（如评审、测试设计、测试执行等）由人来完成，狭义上是指测试执行有人工完成，这是最基本的测试形式

### 自动化测试

一般是指计算机模拟人的测试行为，替代人的测试活动，狭义上是指测试执行由计算机来完成

* 优点
  * 对程序新版本运行前一版本执行的测试，提高回归测试效率
  * 可以运行更多更频繁的测试，比如冒烟测试
  * 可以执行手工测试困难或不可能做的测试，比如大量的重复操作或者集成测试
  * 更好地利用资源，比如测试仪器或者被测对象  
* 缺点
  *   不能取代手工测试，自动化测试只能提高测试效率，不能提高测试有效性，即不可能发现更多缺陷
  * 手工测试比自动测试发现的缺陷更多
  *   对测试设计依赖性极大，测试设计的不好会遗漏问题
  *   自动化测试对软件开发具有很大的依赖性，开发上出现变更可能导致前面的自动化测试完全失效
  *   工具本身并不具备想象力，工具不具有智能  

>   **自动化的优点：**
>
>   ​    1、**更适用于回归测试，**这也是自动化测试的主要任务。由于回归测试的动作和用例是完全设计好的，测试期望的结果也是完全可以预料的，将回归测试自动运行，可以极大提高测试效率，缩短回归测试实践。
>
>   ​    2、**测试效率高，可以在极短的时间内运行更多的测试。**
>
>   ​    3、**可以执行手工测试因为人力等原因不可能或者存在困难的测试。**比如，对于大量用户的测试，不可能同时让足够多的测试人员同时进行测试，但是却可以通过自动化测试模拟同时有许多用户，从而达到测试的目的。
>
>   ​    4、使测试工作得到合理的分配，更有效的利用资源，把可自动化测试的测试自动化后，让测试人员专注手工测试，因为有的测试不适合自动测试，仅适合手工测试。
>
>   ​    5、具有一致性和可重复性，由于测试是自动执行的，每次测试的结果和执行的内容的一致性是可以得到保障的。从而达到测试的可重复的效果。
>
>   ​    6、测试的复用性。由于自动测试通常采用脚本技术，这样就有可能只需要做少量的甚至不做修改，实现在不同的测试过程中使用相同的用例。
>
>   ​    7、增强软件信任度，由于测试是自动执行的，所以不存在执行过程中的疏忽和错误，完全取决于测试的设计质量，一旦软件通过了强有力的自动测试后，软件的信任度自然会增加。
>    
>
>   ​    **自动化的缺点：**
>
>   ​    1、前期准备工作比较繁琐。自动化测试在整个测试周期中何时开展，哪些测试工作可以由自动化测试替代，这些都需要在开始部署自动化测试前，进行思考。
>
>   ​    2、人员要求高。自动化测试用例与手工测试用例大不相同，自动化测试实施过程中，需要不断的开发与维护脚本，因此对测试人员能力有很高要求。
>
>   ​    3、手工测试比自动测试发现的缺陷更多。自动化只能检查一些比较主要问题，如崩溃、死机，但是却无法发现一些一般的日常错误。
>
>   ​    4、测试脚本编写费时。在自动化测试中编写测试脚本工作量很大，有时候该工作量甚至超过了手动测试的时间。
>
>   ​    5、工具本身并无想象力。工具是相对机械、缺乏思维的东西，人是具有很强智能判断能力的动物。
>
>   ​    6、自动化测试不能取代手工测试。各有利弊，需相辅相成。
>
>   ​    7、测试自动化可能会制约软件开发。由于自动测试比手动测试更脆弱，所以维护会受到限制，从而制约软件的开发。
>    
>
>   ​    综上所述，可以归结自动化完成不了的，手工测试都能弥补，两者有效的结合是测试质量的关键。



==[软件测试分类及汇总整理（重点）](https://www.cnblogs.com/findyou/p/6480411.html)==

## 软件测试的流程

- [x] 测试计划阶段 - 测试计划
- [x] 测试设计阶段 - 测试方案
- [x] 测试实现阶段 - ==测试用例==、测试流程ISTQB
- [x] 测试执行阶段 - 测试报告、==缺陷报告==

**软件测试的基本流程（重点）**

1.  测试需求分析阶段：阅读需求，理解需求，主要就是对业务的学习，分析需求点，参与需求评审会议

2.  测试计划阶段：主要任务就是编写测试计划，参考软件需求规格说明书，项目总体计划，内容包括测试范围（来自需求文档），进度安排，人力物力的分配，整体测试策略的制定。风险评估与规避措施有一个制定。

3.  测试设计阶段：主要是编写测试用例，会参考需求文档（原型图），概要设计，详细设计等文档，用例编写完成之后会进行评审。

4.  测试执行阶段：搭建环境，执行冒烟测试（预测试）-然后进入正式测试，bug管理直到测试结束

5.  测试评估阶段：出测试报告，确认是否可以上线

**Plan-Do-Report**

**总结**

==开发流程==：了解用户需求--》进行需求分析--》得知功能组成及设计软件结构--》开发设计计划--》概要设计--》详细设计--》进行软件编码--》单元测试--》代码审查--》打包提交给测试部--》测试部返回bug--》更新修复bug--》再次进入测试部测试-。。。直到bug解决--》版本上线--》面向用户使用

==测试流程==：了解用户需求--》参考需求规格说明书--》测试计划（人力物力时间进度的安排）--》编写测试用例--》评审用例--》搭建环境--》测试包安排预测（冒烟测试）-正式测试-bug-测试结束出报告--》版本上线--》面向用户

#### 主要测试文档

* 测试计划

  指明测试范围、方法、资源，以及相应测试活动的时间进度安排表的文档

* 测试方案

  指明为完成软件或软件集成特性的测试而进行的设计测试方法的细节文档

* ==测试用例==

  指明为完成一个测试项的测试输入、预期结果、测试执行条件等因素的文档

* 测试规程

  指明执行测试时测试活动序列的文档

* 测试报告

  指明执行测试结果的文档

* 测试日报

  每天测试执行情况的记录和总结

**测试计划和测试方案的区别：**

![image-20191222155032058](/images/image-20191222155032058.png)

### 测试工程师在测试各阶段的任务

* 软件需求阶段

  评审软件需求规格说明书

* 软件设计阶段

  评审软件概要设计说明书、软件详细设计说明书、协助编写系统测试计划

* 软件编码阶段

  设计系统测试用例、准备测试资源（测试工具、测试环境等）、开发测试脚本、开发测试工具、准备测试数据

* 软件测试阶段

  执行测试用例、提交缺陷单、跟踪缺陷、回归测试、提交测试报告

## 软件测试质量

软件质量是许多质量属性的综合体现，各种质量属性反应了软件质量的方方面面。人们通过改善软件的各种质量属性，从而提高软件的整体质量。  

* ISO: 质量标准，结果通过或不通过

* **CMMI**（ Capability Maturity Model Integration ）能力成熟度模型集成

  * **CMMI 1**：无级别

     		在完成级水平上，企业对项目的目标与要做的努力很清晰。项目的目标得以实现 

  * **CMMI 2**：已管理级

     		在管理级水平上，企业在项目实施上能够遵守既定的计划与流程，有资源准备，权责到人，对相关的项目实施人员有相应的培训，对整个流程有监测与控制，并与上级单位对项目与流程进行审查。 

  * **CMMI 3：已定义级**

     		在定义级水平上，企业不仅仅能够对项目的实施有一整套的管理措施，并保障项目的完成；而且，企业能够根据自身的特殊情况以及自己的标准流程，将这套管理体系与流程予以制度化。 

  * **CMMI 4：已定量管理级**

     		量化管理级分析对软件工程和产品质量的详细度量数据，对[软件过程](https://www.baidu.com/s?wd=软件过程&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)和产品都有定量的理解与控制，管理有一个做出结论的客观依据。 

  * CMMI5：最优化级

    优化管理级的量化反馈和先进的新思想、新技术促使过程持续不断改进。 
  
  **CMMI和ISO的区别？**
  
* 如何描述质量

    软件的质量属性很多，如正确性、精确性，健壮性、可靠性、容错性、性能、易用性、安全性、可扩展性、可复用性、兼容性、可移植性、可测试性、可维护性、灵活性等。  

* 质量模型： 一组特性及特性之间的关系，它提供规定质量需求和评价质量的基础 

  ![image-20191025185312076](/images/image-20191025185312076.png)

影响软件质量的因素？

影响软件质量的主要因素，这些因素是从管理角度对软件质量的度量。可划分为三组，分别反应用户在使用软件产品时的三种观点。正确性、健壮性、效率、完整性、可用性、风险（产品运行）；可理解性、可维修性、灵活性、可测试性（产品修改）；可移植性、可再用性、互运行性（产品转移）。
[McCall模型](https://www.cnblogs.com/gaochundong/p/software_quality_models.html)

![img](/images/20160108154535977.png)

![img](/images/20160108154707094.png)

### 软件测试与QA的区别

* 从性质上看：
  * 测试属于技术的工作
  * QA属于管理的工作
* 从对象上看：
  * 测试的对象是软件研发产品，大多数工作是对研发领域的检验
  * QA的对象是整个软件过程，覆盖各个领域 

*  从手段上看：
  * 测试以事后检查为主
  * QA强调的是缺陷预防

